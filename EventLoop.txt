1ï¸âƒ£ What is Concurrency in JavaScript?

Concurrency means:

JS can handle multiple tasks at the same time logically, even though it is single-threaded.

ğŸ”‘ JS achieves concurrency using:

Event Loop

Call Stack

Web APIs

Callback Queue

Microtask Queue

ğŸ‘‰ JS does NOT run tasks in parallel (except Web Workers).

2ï¸âƒ£ Is JavaScript Single-Threaded?

âœ… Yes

One Call Stack

One thing executes at a time

No true multi-threading

But still handles async operations efficiently using the Event Loop.

3ï¸âƒ£ What is the Event Loop?

Event Loop is a mechanism that:

Continuously checks whether the call stack is empty and then pushes pending tasks from queues into it.

ğŸ“Œ It enables non-blocking asynchronous behavior.

4ï¸âƒ£ Components of Event Loop
1. Call Stack

Executes synchronous code

LIFO (Last In First Out)

function a() { b(); }
function b() { console.log("Hello"); }
a();

2. Web APIs (Browser / Node.js)

Handles async operations:

setTimeout

setInterval

fetch

DOM events

setTimeout(() => console.log("Hi"), 1000);

3. Callback Queue (Macrotask Queue)

Contains:

setTimeout

setInterval

setImmediate (Node.js)

DOM events

4. Microtask Queue

Contains:

Promise.then / catch / finally

queueMicrotask

MutationObserver

ğŸš¨ Microtasks have higher priority than macrotasks

5ï¸âƒ£ Execution Order (VERY IMPORTANT)

Priority Order:

Call Stack (sync code)

Microtask Queue

Macrotask Queue

6ï¸âƒ£ Example â€“ Event Loop in Action
console.log("Start");

setTimeout(() => {
  console.log("Timeout");
}, 0);

Promise.resolve().then(() => {
  console.log("Promise");
});

console.log("End");

âœ… Output:
Start
End
Promise
Timeout

ğŸ” Why?

Sync code runs first

Promise goes to microtask queue

setTimeout goes to macrotask queue

Microtasks run before macrotasks

7ï¸âƒ£ setTimeout with 0 ms
setTimeout(() => console.log("A"), 0);
console.log("B");

Output:
B
A


ğŸ“Œ 0 ms does NOT mean immediate execution
It means minimum delay after stack is empty

8ï¸âƒ£ Promise vs setTimeout (Common Interview Question)
setTimeout(() => console.log("Timeout"), 0);

Promise.resolve().then(() => console.log("Promise"));

Output:
Promise
Timeout


âœ” Because microtasks run before macrotasks

9ï¸âƒ£ Blocking the Event Loop
while(true) {}


âŒ This blocks:

UI rendering

API calls

Timers

User interaction

ğŸ“Œ Heavy tasks should be offloaded (Web Workers).

ğŸ”Ÿ How JS Achieves Non-Blocking Behavior?

Async tasks handled by Web APIs

Results queued

Event Loop pushes them when stack is empty

ğŸ‘‰ Main thread stays free

1ï¸âƒ£1ï¸âƒ£ Starvation Problem

If microtasks keep getting added continuously:

function loop() {
  Promise.resolve().then(loop);
}
loop();


âŒ Macrotasks may never execute

ğŸ“Œ Called microtask starvation

1ï¸âƒ£2ï¸âƒ£ Event Loop in Browser vs Node.js
Browser	Node.js
Web APIs	Libuv
UI Rendering	No UI
setImmediate âŒ	setImmediate âœ…
1ï¸âƒ£3ï¸âƒ£ Real-World Use Case

API calls (fetch)

Timers

Click handlers

Background tasks

Non-blocking server requests (Node.js)

1ï¸âƒ£4ï¸âƒ£ Interview One-Liners

JavaScript is single-threaded but asynchronous

Event Loop enables concurrency

Promises go to microtask queue

setTimeout goes to macrotask queue

Microtasks execute before macrotasks

1ï¸âƒ£5ï¸âƒ£ Common Interview Questions

âœ… What is the event loop?
âœ… Why promises execute before setTimeout?
âœ… What happens if call stack is not empty?
âœ… Difference between microtask & macrotask?
âœ… Is JS multi-threaded?
âœ… What is blocking code?